---
title: "HAX603X: Modélisation stochastique"
subtitle: "Introduction"
format:
  revealjs:
    toc: true
    template-partials:
        - toc-slide.html
    include-after-body: toc-add.html
---

# Présentation, informations générales


##
![](https://raw.githubusercontent.com/josephsalmon/OrganizationFiles/master/inkscape/images/contact_js.svg)

<br>
<br>
<br>

PS: n'oubliez pas de mettre [HAX603X] dans le titre de vos mails!


## Enseignants:
::: {.fragment fragment-index=1}
- **Joseph Salmon** : CM et TP
    - Situation actuelle : Professeur à l'Université de Montpellier
    - Précédemment : Paris Diderot-Paris 7, Duke Univ., Télécom ParisTech, Univ. Washington
    - Spécialités : statistiques, optimisation, traitement des images, sciences participatives
    - Bureau : 415, Bat. 9
:::
<div style="line-height:4%;">
<br>
</div>

::: {.fragment fragment-index=2}
- **Benjmain Charlier** : CM, TD et TP
  - Situation actuelle : Maître de conférence l'Université de Montpellier
  - Précédemment : Université Paul Sabatier, ENS Paris-Saclay
  - Spécialités : traitement des images, statistiques, différentiation automatique
  - Bureau : 423, Bat. 9
:::

## Ressources en ligne


[Informations principales]{.underline} : site du cours <http://josephsalmon.github.io/HAX603X>


:::{.incremental}

- Syllabus
- Slides (au fil de l'eau)
- Poly (au fil de l'eau)
- Feuilles de TD
- Feuilles de TP
- Rendu TP : Moodle de l'université (https://moodle.umontpellier.fr/course/view.php?id=5558)

:::

## Validation

- TP notés : Rendu = fichier Python **.py** unique

   - TP noté 1 : rendre en fin de session (date TBD)
   - TP noté 2 : rendre en fin de session (date TBD)

- CC : devoir sur table d'une heure

<br>

- Coefficients:
    - Note Session 1 : (40% CC + 30% TP 1 + 30% TP 2)
    - Note Session 2 : (30% CC + 35% TP 1 + 35% TP 2)

::: {.callout-warning}
Le rendu est individuel pour le TP noté !!!
:::

## Notation pour les TPs

[Rendu]{.underline} : sur Moodle, en déposant un fichier nom_prenom.py
dans le dossier adéquat.

Détails de la notation du TP :

- Qualité des réponses aux questions
- Qualité de rédaction et d’orthographe
- Qualité des graphiques (légendes, couleurs)
- Qualité d’écriture du code (noms de variables clair, commentaires utiles, code synthétique, etc.)
- Notebook reproductible et absence de bug

<br>

[Pénalités]{.underline} :

- Envoi par mail : zéro
- Retard : zéro (uploader avant la fin, fermeture automatique de moodle)


## Prérequis - à revoir seul

- Bases de probabilités [@Foata_Fuchs96]: probabilité, densité, espérance, fonction de répartition

- Programmation élémentaire : if then else, for, while, fonctions, etc.


## Description du cours

[Objectifs]{.underline} :

- Méthode de génération aléatoire
- Réduction de variance, enjeux computationnels
- XXX
- XXX
- utilisation de Python pour la génération d'éléments aléatoires
- visualisation (matplotlib, seaborn)
- introduire des bonnes pratiques numériques valables pour tous les langages (lisibilité, documentation)


##
```{=html}
<div id='toc'></div>
```
# Perspectives historiques

## L'aiguille de Buffon

::::{.columns}

:::{.column width="60%"}

- 1733:  **l'aiguille de Buffon**, méthode d'estimation de la valeur de $\pi$. 
Première méthode de Monte-Carlo de la littérature .

::: {.fragment}
**Problème initial**: une aiguille de taille 1 tombe sur un parquet composé de lattes de largeur $1$: quelle est alors la probabilité $P$ que l'aiguille croise une ligne de la trame du parquet ?
:::

::: {.fragment}
```{python}
#| layout-ncol: 1
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots

rng = np.random.default_rng(44)

n_samples = 200
xmax = 14.499999
xmin = -xmax


# Create the needles
centers_x = rng.uniform(xmin, xmax, n_samples)
angles = rng.uniform(0, 2 * np.pi, n_samples)
centers_y = rng.uniform(-2, 2, n_samples)

# Compute the right borders of the needles
borders_right = np.zeros((n_samples, 2))
borders_right[:, 0] = centers_x + np.cos(angles) / 2
borders_right[:, 1] = centers_y + np.sin(angles) / 2

# Compute the left borders of the needles
borders_left = np.zeros((n_samples, 2))
borders_left[:, 0] = centers_x + np.cos(angles + np.pi) / 2
borders_left[:, 1] = centers_y + np.sin(angles + np.pi) / 2

centers_x_round = np.round(centers_x)
overlap = (borders_right[:, 0] - centers_x_round) * (
    borders_left[:, 0] - centers_x_round
) < 0
overlap = np.where(overlap, 1, 0)
n_overlap = int(np.sum(overlap))


# Check if the needles cross a line
borders_red = np.empty((3 * n_overlap, 2), dtype=object)
borders_red.fill(None)
borders_red[::3, :] = borders_right[overlap == 1]
borders_red[1::3, :] = borders_left[overlap == 1]

borders_blue = np.empty((3 * (n_samples - n_overlap), 2), dtype=object)
borders_blue.fill(None)
borders_blue[::3, :] = borders_right[overlap == 0]
borders_blue[1::3, :] = borders_left[overlap == 0]

overlaps = np.empty((3 * n_samples), dtype=object)
overlaps.fill(None)
overlaps[::3] = overlap
overlaps[1::3] = overlap
overlaps[2::3] = overlap

idx_red = np.cumsum(overlaps)
idx_blue = np.cumsum(1 - overlaps)


# Create subplots with 2 rows and 1 column with ratio x /  y  of 10
fig = make_subplots(rows=1, cols=1)

# Use a loop to plot vertical lines equation "y=c" for integer values c in [-2, -1, 0, 1, 2]
for i in range(int(np.round(xmin)), int(np.round(xmax)) + 1):
    fig.add_shape(
        type="line",
        y0=-3,
        x0=i,
        y1=3,
        x1=i,
        line=dict(
            color="black",
            width=2,
        ),
    )

color = np.where(overlaps, 1.0, 0.0)

n_samples_array = np.arange(1, n_samples + 1)
pi_estimate = 2 / (np.cumsum(overlap) / n_samples_array)
t = n_samples

fig.update_layout(
    template="simple_white",
    xaxis=dict(range=[xmin, xmax], constrain="domain", showgrid=False),
    yaxis_scaleanchor="x",
    xaxis_visible=False,
    yaxis_visible=False,
)


i = 20
fig.add_trace(
    go.Scatter(
        x=borders_red[: idx_red[3 * i] + 1, 0],
        y=borders_red[: idx_red[3 * i] + 1, 1],
        mode="lines",
        line=dict(width=2),
        marker=dict(color="red"),
        name="Avec intersection",
        visible=True,
    ),
)
fig.add_trace(
    go.Scatter(
        x=borders_blue[: idx_blue[3 * i] + 1, 0],
        y=borders_blue[: idx_blue[3 * i] + 1, 1],
        mode="lines",
        line=dict(width=2),
        marker=dict(color="darkblue"),
        name="Sans intersection",
        visible=True,
    ),
)

fig.update_layout(legend=dict(x=0.5, y=1, xanchor='center', yanchor='top'))
fig.show()
```

:::

:::

:::{.column width="40%"}
[Georges-Louis Leclerc, Comte de Buffon](https://fr.wikipedia.org/wiki/Georges-Louis_Leclerc_de_Buffon): (1707-1788)
 naturaliste, mathématicien et industriel français du siècle des Lumières<img src="https://upload.wikimedia.org/wikipedia/commons/b/b5/Georges-Louis_Leclerc_de_Buffon.jpg" width="65%" style="display: block; margin-right: auto; margin-left: auto;" alt="Portrait de Georges-Louis Leclerc, comte de Buffon.
Huile sur toile de François-Hubert Drouais, Montbard, musée Buffon." title="Portrait de Georges-Louis Leclerc, comte de Buffon.
Huile sur toile de François-Hubert Drouais, Montbard, musée Buffon."></img>

:::

::::


## L'aiguille de Buffon (suite)

::: {.fragment}

**Problème initial**: une aiguille de taille 1 tombe sur un parquet composé de lattes de largeur $1$: quelle est alors la probabilité $P$ que l'aiguille croise une ligne de la trame du parquet ?
:::

<br>

::: {.fragment}
**Réponse**:
$$
P = \frac{2}{\pi} \approx 0.6366 \enspace.
$$
Une preuve de ce résultat est donnée [ici](http://josephsalmon.github.io/HAX603X/perspective_historique.html).
:::

## Principe de Monte Carlo pour estimer $\pi$


L'idée sous-jacente de Buffon : 

si l'on répète cette expérience un grand nombre de fois, on peut approché la quantité $P$ numériquement, par exemple en proposant un estimateur $\hat{P}_n$ qui compte la proportion de chevauchement après avoir fait $n$ répétition des lancers.


Pour estimer $\pi$, il ne restera donc plus qu'à évaluer $\frac{2}{\hat{P}_n}$.

## Principe de Monte Carlo pour estimer $\pi$ (suite)

```{python}
#| layout-ncol: 1

# Create subplots with 2 rows and 1 column with ratio x /  y  of 10
fig1 = make_subplots(rows=2, cols=1, vertical_spacing=0.1, row_heights=[2, 1])

# Use a loop to plot vertical lines equation "y=c" for integer values c in [-2, -1, 0, 1, 2]
for i in range(int(np.round(xmin)), int(np.round(xmax)) + 1):
    fig1.add_shape(
        type="line",
        y0=-3,
        x0=i,
        y1=3,
        x1=i,
        line=dict(
            color="black",
            width=2,
        ),
        row=1,
        col=1,
    )

color = np.where(overlaps, 1.0, 0.0)

n_samples_array = np.arange(1, n_samples + 1)
pi_estimate = 2 / (np.cumsum(overlap) / n_samples_array)
t = n_samples

fig1.update_layout(
    template="simple_white",
    xaxis=dict(range=[xmin, xmax], constrain="domain", showgrid=False),
    yaxis_scaleanchor="x",
    xaxis_visible=False,
    yaxis_visible=False,
)

for i in range(3, t):
    fig1.add_trace(
        go.Scatter(
            x=borders_red[: idx_red[3 * i] + 1, 0],
            y=borders_red[: idx_red[3 * i] + 1, 1],
            mode="lines",
            line=dict(width=2),
            marker=dict(color="red"),
            name="Avec intersection",
            visible=False,
        ),
        row=1,
        col=1,
    )
    fig1.add_trace(
        go.Scatter(
            x=borders_blue[: idx_blue[3 * i] + 1, 0],
            y=borders_blue[: idx_blue[3 * i] + 1, 1],
            mode="lines",
            line=dict(width=2),
            marker=dict(color="darkblue"),
            name="Sans intersection",
            visible=False,
        ),
        row=1,
        col=1,
    )

    fig1.add_trace(
        go.Scatter(
            x=n_samples_array[:i],
            y=pi_estimate[:i],
            mode="lines",
            line=dict(width=1),
            marker=dict(color="red"),
            showlegend=False,
            visible=False,
        ),
        row=2,
        col=1,
    )

fig1.add_annotation(
    dict(
        x=1.25,
        y=0.14,
        xref="paper",
        yref="paper",
        text="Estimation de pi",
        showarrow=False,
        font=dict(color="red"),
    )
)

fig1.add_annotation(
    dict(x=-0.04, y=0.19, xref="paper", yref="paper", text="pi", showarrow=False)
)

fig1.update_xaxes(title_text="Nombre d'aiguilles tirées", row=2, col=1)

fig1.update_layout(
    template="none",
    xaxis2=dict(showgrid=True, zeroline=True, zerolinewidth=1, range=[0, n_samples]),
    yaxis2=dict(showgrid=True, zeroline=True, zerolinewidth=1, range=[0, 6]),
)
# plot a dash line at y=pi
fig1.add_shape(
    type="line",
    y0=np.pi,
    x0=0,
    y1=np.pi,
    x1=n_samples,
    line=dict(
        color="black",
        width=1,
        dash="dashdot",
    ),
    row=2,
    col=1,
)


fig1.data[11 * 3].visible = True
fig1.data[11 * 3 + 1].visible = True
fig1.data[11 * 3 + 2].visible = True


steps = []
for ii in range(len(fig1.data) // 3):
    step = dict(
        label=str(ii + 4),
        method="update",
        args=[
            {"visible": [False] * len(fig1.data)},
            {
                "title": "Estimation avec "
                + str(ii + 4)
                + f" aiguilles: pi = {pi_estimate[ii]:.4f}"
            },
        ],
    )
    step["args"][0]["visible"][3 * ii] = True
    step["args"][0]["visible"][3 * ii + 1] = True
    step["args"][0]["visible"][3 * ii + 2] = True

    steps.append(step)

slider = dict(
    active=6,
    currentvalue={"prefix": "Nombre d'aiguilles: "},
    pad={"t": 50},
    y=-0.32,
    steps=steps,
)

fig1.update_layout(legend=dict(x=0.5, y=1, xanchor='center', yanchor='bottom'))
fig1.update_layout(sliders=[slider])
fig1.show()
```


## Quantiles: cas continu

::::{.columns}

:::{.column width="38%"}

```{ojs}
//| echo: false
// Plotly = require("https://cdn.plot.ly/plotly-latest.min.js")
Plotly = require('plotly.js-dist');
dists = require( 'https://cdn.jsdelivr.net/gh/stdlib-js/stats-base-dists@umd/browser.js' );
// see source here: https://github.com/stdlib-js/stats-base-dists/tree/umd
// continuous case
jstatPDFs = () => {
  const distributions = Object.keys(dists);
  // Get in continuousDistributions the distributions whose pdf, cdf and quantile are defined
    const continuousDistributions = distributions.filter(name => dists[name].pdf && dists[name].cdf && dists[name].quantile);
  return continuousDistributions
};
output = jstatPDFs();

excludedPDFs = [];
pdfNames_unsorted = output.filter(name => !excludedPDFs.includes(name));
pdfNames=pdfNames_unsorted.toSorted();
viewof inputs = Inputs.form([
      Inputs.range([-10, 10], {value: 0.1, step: 0.001, label: tex`\mu`, width: 500}),
      Inputs.range([0.01, 5], {value: 1.01, step: 0.001, label: tex`\sigma`, width: 500}),
      Inputs.range([0.001, 0.999], {value: 0.75, step: 0.001, label:tex`\alpha`, width: 500}),
    ]);


viewof distrib_name = Inputs.select(pdfNames, {value: "normal", label: "Loi", width: 500});

```

:::

:::{.column width="60%"}


```{ojs}

{
  const x = d3.range(-5, 5, 0.01);
  const pdf = x.map(x => dists[distrib_name].pdf(x, mu, sigma));
  const cdf = x.map(x => dists[distrib_name].cdf(x, mu, sigma));
  const inv = x.map(x => dists[distrib_name].quantile(x, mu, sigma));
  const quantile = dists[distrib_name].quantile(alpha, mu, sigma);
  const filteredX = x.filter(coord => coord <= quantile);
  const filteredPdf = pdf.filter((_, i) => x[i] <= quantile);
  const filteredCdf = cdf.filter(coord => coord <= quantile);


{
var trace1 = {
      type: "scatter",
      name: 'Quantile',
      x : cdf,
      y : x,
      line: {color: 'black'},
      xaxis: 'x1',
      yaxis: 'y3',


};

var trace12 = {
        x : [alpha, alpha],
        y : [x[0], quantile],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y3',


};



var trace13 = {
    x: [0, alpha],
    y: [quantile, quantile],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x1',
    yaxis: 'y3'
}


var trace2 = {
x: cdf,
y: cdf,
type: 'scatter',
name: 'identity',
line: {color: 'black'},
xaxis: 'x1',
yaxis: 'y2'

};


var trace21 = {
        x : [alpha, 1],
        y : [alpha, alpha],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y2'
}

var trace22 = {
        x : [alpha, alpha],
        y : [alpha, 1],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y2'
}



var trace23 = {
    x: [alpha],
    y: [alpha],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x1',
    yaxis: 'y2'
}


var trace31 = {
      type: "scatter",
      mode: "lines",
      name: 'PDF2',
      x: x,
      y: cdf,
      line: {color: 'black'},
      xaxis: 'x2',
      yaxis: 'y2',
};

var trace32 = {
        x : filteredX,
        y : filteredX.map(x => alpha),
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }
          },
      xaxis: 'x2',
      yaxis: 'y2'
}

var trace33 = {
        x : [quantile, quantile],
        y : [0, alpha],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }
          },

      xaxis: 'x2',
      yaxis: 'y2'
}

var trace34 = {
    x: [quantile],
    y: [alpha],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x2',
    yaxis: 'y2'
}


var trace41 = {

  type: "scatter",
  name: 'Quantile2',
  fill: 'tozeroy',
  x : filteredX,
  y : filteredPdf,
  opacity: 0.9,
  line: {color: ' #428BCA'},
  xaxis: 'x2',
  yaxis: 'y1'

};


var trace42 = {

  type: "scatter",
  mode: "lines",
  name: 'PDF2',
  x: x,
  y: pdf,
  line: {color: 'black'},
  xaxis: 'x2',
  yaxis: 'y1'

};

var data = [
  trace1,
  trace12, trace13,
  trace2, trace21, trace22, trace23,
  trace31, trace32, trace33, trace34,
  trace41, trace42];


var layout = {

  title: 'Distribution et quantile',
  xaxis: {
    domain: [0, 0.32],
    anchor: 'y1'
  },
  yaxis: {
    domain: [0, 0.24],
    anchor: 'x1'

  },
  xaxis2: {
    domain: [0.35, 1],
    anchor: 'y'
  },

  yaxis2: {
    domain: [0.26, 0.49],
    anchor: 'x1'
  },

  yaxis3: {
    domain: [0.5, 1],
    anchor: 'x1'
  },

// legend offset
  showlegend: false,
  height: 680,
  annotations: [

    {
      x: 1/4,
      y: quantile - (x[0]-x.slice(-1))/20,
      xref: 'x1',
      yref: 'y3',
      text: 'q= ' + quantile.toFixed(2),
      font: {
        size: 12,
        color: '#428BCA',

      },
      showarrow: false,
      arrowhead: 0,
      ax: 25,
      ay: -10,

    },
    {
      x: 1/4,
      y: alpha,
      xref: 'x1',
      yref: 'y2',
      text: 'alpha= ' + alpha.toFixed(2),
      font: {
        size: 12,
        color: '#428BCA',

      },
      showarrow: false,
      arrowhead: 0,
      ax: 25,
      ay: -10,

    },
    {
        text: "Fonction quantile",
      font: {
      size: 15,
      color: 'black',
    },
    showarrow: false,
    align: 'center',
    x: -0.01,
    y: 1.05,
    xref: 'paper',
    yref: 'paper',
    },
    {
      text: "Fonction de répartition",
      font: {
      size: 15,
      color: 'black',
            },
    showarrow: false,
    align: 'center',
    x: 0.65,
    y: 0.52,
    xref: 'paper',
    yref: 'paper',
    },
    {
      text: "Fonction de densité",
      font: {
      size: 15,
      color: 'black',
            },
    showarrow: false,
    align: 'center',
    x: 0.65,
    y: 0.225,
    xref: 'paper',
    yref: 'paper',
    },
  ]

};
// XXX: TODO: put the xticks labels on the middle plot for x and on the right plot for y
    var config = {responsive: true}
    const div = DOM.element('div');
    Plotly.newPlot(div, data, layout, config);
    return div;
  }

}

mu = inputs[0];
sigma = inputs[1];
alpha = inputs[2]
```
:::


::::
<br>

[Note]{.underline}: voir aussi [Notations et rappels](https://josephsalmon.github.io/HAX603X/Courses/notations.html#) 



## Quantiles: cas discret


::::{.columns}

:::{.column width="38%"}

```{ojs}
//| echo: false
discretePDFs = () => {
  const distributions = Object.keys(dists);
  // Get in continuousDistributions the distributions whose pdf, cdf and quantile are defined
    const continuousDistributions = distributions.filter(name => dists[name].pmf && dists[name].cdf && dists[name].quantile);
  return continuousDistributions
};
output_discr = discretePDFs();

pmfNames_unsorted = output_discr.filter(name => !excludedPDFs.includes(name));
pmfNames=pmfNames_unsorted.toSorted();
viewof inputs_disc = Inputs.form([
      Inputs.range([-10, 10], {value: 0.1, step: 0.001, label: tex`\mu `, width: 500}),
      Inputs.range([0.01, 5], {value: 1.01, step: 0.001, label: tex`\sigma `, width: 500}),
      Inputs.range([0.001, 0.999], {value: 0.75, step: 0.001, label: tex`\alpha`, width: 500}),
    ]);

viewof distrib_name_discr = Inputs.select(pmfNames, {value: "normal", label: "Loi", width: 500});
```

:::

:::{.column width="60%"}

```{ojs}

{
  const z = d3.range(-5, 5, 0.01);
  const pmf = z.map(z => dists[distrib_name_discr].pmf(z, mu_disc, sigma_disc));
  const cdf = z.map(z => dists[distrib_name_discr].cdf(z, mu_disc, sigma_disc));
  const inv = z.map(z => dists[distrib_name_discr].quantile(z, mu_disc, sigma_disc));
  const quantile = dists[distrib_name_discr].quantile(alpha_disc, mu_disc, sigma_disc);
  const filteredX = z.filter(coord => coord <= quantile);
  const filteredPmf = pmf.filter((_, i) => z[i] <= quantile);
  const filteredCdf = cdf.filter(coord => coord <= quantile);


{
var trace1 = {
      type: "scatter",
      name: 'Quantile',
      x : cdf,
      y : z,
      line: {color: 'black'},
      xaxis: 'x1',
      yaxis: 'y3',


};

var trace12 = {
        x : [alpha_disc, alpha_disc],
        y : [z[0], quantile],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y3',


};



var trace13 = {
    x: [0, alpha_disc],
    y: [quantile, quantile],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x1',
    yaxis: 'y3'
}


var trace2 = {
x: cdf,
y: cdf,
type: 'scatter',
name: 'identity',
line: {color: 'black'},
xaxis: 'x1',
yaxis: 'y2'

};


var trace21 = {
        x : [alpha_disc, 1],
        y : [alpha_disc, alpha_disc],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y2'
}

var trace22 = {
        x : [alpha_disc, alpha_disc],
        y : [alpha_disc, 1],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }

          },
      xaxis: 'x1',
      yaxis: 'y2'
}

var trace23 = {
    x: [alpha_disc],
    y: [alpha_disc],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x1',
    yaxis: 'y2'
}


var trace31 = {
      type: "scatter",
      mode: "lines",
      name: 'PDF2',
      x: z,
      y: cdf,
      line: {color: 'black'},
      xaxis: 'x2',
      yaxis: 'y2',
};

var trace32 = {
        x : filteredX,
        y : filteredX.map(z => alpha_disc),
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }
          },
      xaxis: 'x2',
      yaxis: 'y2'
}

var trace33 = {
        x : [quantile, quantile],
        y : [0, alpha_disc],
        mode: 'lines',
        line: {
            dash: 'dash',
            width: 1,
            color: ' #428BCA',
            marks: {
                size: 0,
                color: ' #428BCA',
            }
          },

      xaxis: 'x2',
      yaxis: 'y2'
}

var trace34 = {
    x: [quantile],
    y: [alpha],
    mode: 'scatter',
    line: {
        dash: 'dash',
        width: 1,
        color: ' #428BCA',
        marks: {
            size: 0,
        }
    },
    xaxis: 'x2',
    yaxis: 'y2'
}


var trace41 = {

  type: "scatter",
  name: 'Quantile2',
  fill: 'tozeroy',
  x : filteredX,
  y : filteredPmf,
  opacity: 0.9,
  line: {color: ' #428BCA'},
  xaxis: 'x2',
  yaxis: 'y1'

};


var trace42 = {

  type: "scatter",
  mode: "lines",
  name: 'PDF2',
  x: z,
  y: pmf,
  line: {color: 'black'},
  xaxis: 'x2',
  yaxis: 'y1'

};

var data = [
  trace1,
  trace12, trace13,
  trace2, trace21, trace22, trace23,
  trace31, trace32, trace33, trace34,
  trace41, trace42];


var layout = {

  title: 'Distribution et quantile',
  xaxis: {
    domain: [0, 0.32],
    anchor: 'y1'
  },
  yaxis: {
    domain: [0, 0.24],
    anchor: 'x1'

  },
  xaxis2: {
    domain: [0.35, 1],
    anchor: 'y'
  },

  yaxis2: {
    domain: [0.26, 0.49],
    anchor: 'x1'
  },



  yaxis3: {
    domain: [0.5, 1],
    anchor: 'x1'

  },

  showlegend: false,
  height: 680,


  annotations: [

    {
      x: 1/4,
      y: quantile - (z[0]-z.slice(-1))/20,
      xref: 'x1',
      yref: 'y3',
      text: 'q=' + quantile.toFixed(2),
      font: {
        size: 12,
        color: '#428BCA',

      },
      showarrow: false,
      arrowhead: 0,
      ax: 25,
      ay: -10,

    },
    {
      x: 1/4,
      y: alpha_disc,
      xref: 'x1',
      yref: 'y2',
      text: 'alpha=' + alpha_disc.toFixed(2),
      font: {
        size: 12,
        color: '#428BCA',

      },
      showarrow: false,
      arrowhead: 0,
      ax: 25,
      ay: -10,

    },
    {
        text: "Fonction quantile",
      font: {
      size: 15,
      color: 'black',
    },
    showarrow: false,
    align: 'center',
    x: -0.01,
    y: 1.05,
    xref: 'paper',
    yref: 'paper',
    },
    {
      text: "Fonction de répartition",
      font: {
      size: 15,
      color: 'black',
            },
    showarrow: false,
    align: 'center',
    x: 0.65,
    y: 0.52,
    xref: 'paper',
    yref: 'paper',
    },
    {
      text: "Fonction de densité",
      font: {
      size: 15,
      color: 'black',
            },
    showarrow: false,
    align: 'center',
    x: 0.65,
    y: 0.225,
    xref: 'paper',
    yref: 'paper',
    },
  ]

};
// XXX: TODO: put the xticks labels on the middle plot for x and on the right plot for y

    var config = {responsive: true}
    const div = DOM.element('div');
    Plotly.newPlot(div, data, layout, config);
    return div;
  }

}

mu_disc = inputs_disc[0];
sigma_disc = inputs_disc[1];
alpha_disc = inputs_disc[2];
```
:::

::::



##  Méthode de Monte-Carlo

Méthode de calcul numérique qui consiste à utiliser des nombres aléatoires pour résoudre des problèmes déterministes.


Domaines d'applications:

 - la physique
 - la chimie
 - la biologie
 - la finance
 - l’apprentissage automatique


## Contexte de la naissance de la méthode de Monte Carlo

::::{.columns}

:::{.column width="70%"}


- Lieu: Los Alamos
- Époque: seconde guerre mondial
- Contexte: **Projet Manathan**, produire une bombe atomique (leader: Oppenheimer)
- Besoins: modéliser les réactions nucléaires en chaîne


::: {layout-ncol=3}

![[John von Neumann](https://fr.wikipedia.org/wiki/John_von_Neumann)(1903-1957), mathématicien et physicien américano-hongrois, un des pères de l'informatique.](https://upload.wikimedia.org/wikipedia/commons/d/d6/JohnvonNeumann-LosAlamos.jpg){height=200}

![[Nicholas Metropolis](https://fr.wikipedia.org/wiki/Nicholas_Metropolis) (1915-1999), physicien gréco-américain, un des initiateurs de la méthode de Monte Carlo et du recuit simulé](https://upload.wikimedia.org/wikipedia/commons/5/56/Nicholas_Metropolis_cropped.PNG){height=200}

![[Stanisław Ulam](https://fr.wikipedia.org/wiki/Stanislaw_Ulam) (1909-1984),  mathématicien polono-américainm, un des initiateurs de la méthode de Monte Carlo et de la propulsion nucléaire pulsée](https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Stanislaw_Ulam.tif/lossy-page1-413px-Stanislaw_Ulam.tif.jpg){height=200}
:::

:::

:::{.column width="30%"}

![Explosion de Trinity (16 Juillet 1945)](https://upload.wikimedia.org/wikipedia/commons/f/fc/Trinity_Detonation_T%26B.jpg){width=100%}

:::

::::




<!-- [John von Neumann](https://fr.wikipedia.org/wiki/John_von_Neumann)^[[John von Neumann](https://fr.wikipedia.org/wiki/John_von_Neumann):  (1903-1957) mathématicien et physicien américano-hongrois, un des pères de l'informatique.
<img src="https://upload.wikimedia.org/wikipedia/commons/d/d6/JohnvonNeumann-LosAlamos.jpg" width="10%" style="display: block; margin-right: auto; margin-left: auto;" title="Unless otherwise indicated, this information has been authored by an employee or employees of the Los Alamos National Security, LLC (LANS), operator of the Los Alamos National Laboratory under Contract No. DE-AC52-06NA25396 with the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this information. The public may copy and use this information without charge, provided that this Notice and any statement of authorship are reproduced on all copies. Neither the Government nor LANS makes any warranty, express or implied, or assumes any liability or responsibility for the use of this information." alt="Unless otherwise indicated, this information has been authored by an employee or employees of the Los Alamos National Security, LLC (LANS), operator of the Los Alamos National Laboratory under Contract No. DE-AC52-06NA25396 with the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this information. The public may copy and use this information without charge, provided that this Notice and any statement of authorship are reproduced on all copies. Neither the Government nor LANS makes any warranty, express or implied, or assumes any liability or responsibility for the use of this information."></img>], 
[Nicholas Metropolis](https://fr.wikipedia.org/wiki/Nicholas_Metropolis)^[[Nicholas Metropolis](https://fr.wikipedia.org/wiki/Nicholas_Metropolis):  (1915-1999)
<img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Nicholas_Metropolis_cropped.PNG" width="10%" style="display: block; margin-right: auto; margin-left: auto;" title="Nicholas Metropolis à Los Alamos National Laboratory" alt="Nicholas Metropolis à Los Alamos National Laboratory"></img>] ou encore [Stanisław Ulam](https://fr.wikipedia.org/wiki/Stanislaw_Ulam)^[[Stanisław Ulam](https://fr.wikipedia.org/wiki/Stanislaw_Ulam):  (1909-1984)
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/Stanislaw_Ulam.tif/lossy-page1-413px-Stanislaw_Ulam.tif.jpg" width="10%" style="display: block; margin-right: auto; margin-left: auto;" title="Unless otherwise indicated, this information has been authored by an employee or employees of the Los Alamos National Security, LLC (LANS), operator of the Los Alamos National Laboratory under Contract No. DE-AC52-06NA25396 with the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this information. The public may copy and use this information without charge, provided that this Notice and any statement of authorship are reproduced on all copies. Neither the Government nor LANS makes any warranty, express or implied, or assumes any liability or responsibility for the use of this information." alt="Unless otherwise indicated, this information has been authored by an employee or employees of the Los Alamos National Security, LLC (LANS), operator of the Los Alamos National Laboratory under Contract No. DE-AC52-06NA25396 with the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this information. The public may copy and use this information without charge, provided that this Notice and any statement of authorship are reproduced on all copies. Neither the Government nor LANS makes any warranty, express or implied, or assumes any liability or responsibility for the use of this information."></img>] -->



## Bibliographie

::: {#refs}
:::