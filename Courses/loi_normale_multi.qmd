---
title: "Loi normale: cas multivari√©"
format:
  html:
      out.width: 50%
filters:
  - shinylive
---


## Introduction

```{ojs}
//| echo: false
//| layout-ncol: 1
// Plotly = require("https://cdn.plot.ly/plotly-latest.min.js")
Plotly = require('plotly.js-dist');
dists = require( 'https://cdn.jsdelivr.net/gh/stdlib-js/stats-base-dists@umd/browser.js' );
math = require("mathjs");
// see source here: https://github.com/stdlib-js/stats-base-dists/tree/umd
// continuous case

viewof inputs = Inputs.form([
  Inputs.range([-1, 1], {label: tex`\mu_1`, step: 0.1}),
  Inputs.range([-1, 1], {label: tex`\mu_2`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_1`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_2`, step: 0.1, value: 0.3}),
  Inputs.range([0, 6.29], {label: tex`\theta`, step: 0.01}),
  Inputs.range([1, 100], {label: tex`n`, step: 1}),
  Inputs.button("Re-Tirage")
])








mu1 = inputs[0];
mu2 = inputs[1];
sigma1 = inputs[2];
sigma2 = inputs[3];
theta = inputs[4];
n_samples = inputs[5];


function create_sigma(theta, sigma1, sigma2){
  const mat_rot = math.matrix([[math.cos(theta), -math.sin(theta)], [math.sin(theta), math.cos(theta)]]);
  const mat_sigma = math.matrix([[sigma1**2, 0], [0, sigma2**2]]);
  return math.multiply(mat_rot, math.multiply(mat_sigma, math.transpose(mat_rot)));
}


function mvnpdf(x, mu, Sigma){
  const p = math.matrix(mu).size()[0];
    return (2*math.pi)**(-p/2)*math.det(Sigma)**(-0.5)*
      math.exp(-0.5*math.multiply( math.multiply( math.transpose(math.subtract(x,mu)), math.inv(Sigma)), math.subtract(x,mu)))
}

{

var npoints=100, mini = -5, maxi=5, x = new Array(npoints), y = new Array(npoints), z = new Array(npoints), i, j;

//  create x y and z arrays for the contour plot, with x and y in the range -5, 5, for npoints points
for(var i = 0; i < npoints; i++) {
    x[i] = mini + i * (maxi - mini) / (npoints - 1);
    y[i] = mini + i * (maxi - mini) / (npoints - 1);
    z[i] = new Array(npoints);
    }

for(var i = 0; i < npoints; i++) {
  	for(j = 0; j < npoints; j++) {

    	z[i][j] = mvnpdf([x[i], x[j]], [mu1,mu2], create_sigma(theta, sigma1, sigma2));
 	}

}


// function randn(n){
//   return d3.range(n).map(d => jstat.normal.sample(0,1))
// }

// const p = math.matrix([mu1,mu2]).size()[0]

// // create samples from the Gaussian distribution with the given parameters
// var samples = math.add([mu1,mu2], math.multiply(jstat.cholesky(create_sigma(theta, sigma1, sigma2)),randn(p))) ;




{

var trace22 = {
        x: x,
        y: y,
        z: z,
        type: 'surface',
        colorscale: 'Oranges',
        showscale: false,
        color: {
            legend: false,
            label: "pdf",
        },

}


var trace21 = {
        x: x,
        y: y,
        z: z,
        type: 'contour',
        colorscale: 'Oranges',
        color: {
            legend: true,
            label: "pdf",
        },
        blur: 4,
        xaxis: 'x2',
}






var data = [
  trace21,
  trace22,
  ];


var layout = {
    scene: {
        camera: {
            eye: {
                x: 0.5,
                y: 1.2,
                z: 1.5,
            }
        }
    },
  grid: {
    rows: 1,
    columns: 2,
    subplots: [['xy','x2y']]
   },

    showlegend: false,

};

    var config = {responsive: true}
    const div = DOM.element('div');
    Plotly.newPlot(div, data, layout, config);
    return div;
  }

}

```