---
title: "Loi normale: cas multivarié"
format:
  html:
      out.width: 50%
filters:
  - shinylive
---


## Introduction


Loi normale multivariée: $\mu \in \mathbb{R}^p$ et $\Sigma \in \mathbb{R}^{p \times p}$ (symétrique et définie positive).
$$
X \sim \mathcal{N}(\mu,\Sigma), \quad \forall x \in \mathbb{R}^p
$$


Densité de probabilité :
$$
\phi(x) = \frac{1}{ \sqrt{2\pi |\Sigma|}}  \exp\Big( -\tfrac{1}{2}(x-\mu)^\top\Sigma^{-1}(x - \mu)   \Big)
$$

```{ojs}
//| echo: false
//| layout-ncol: 1
// Plotly = require("https://cdn.plot.ly/plotly-latest.min.js")
Plotly = require('plotly.js-dist');
dists = require( 'https://cdn.jsdelivr.net/gh/stdlib-js/stats-base-dists@umd/browser.js' );
jstat = require('jstat');
math = require("mathjs");
// see source here: https://github.com/stdlib-js/stats-base-dists/tree/umd
// continuous case

viewof inputs = Inputs.form([
  Inputs.range([-1, 1], {label: tex`\mu_1`, step: 0.1}),
  Inputs.range([-1, 1], {label: tex`\mu_2`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_1`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_2`, step: 0.1, value: 0.3}),
  Inputs.range([0, 6.29], {label: tex`\theta`, step: 0.01}),
  Inputs.range([1, 100], {label: tex`n`, step: 1}),
  Inputs.button("Re-Tirage")
])


mu1 = inputs[0];
mu2 = inputs[1];
sigma1 = inputs[2];
sigma2 = inputs[3];
theta = inputs[4];
n_samples = inputs[5];


function create_sigma(theta, sigma1, sigma2){
  const mat_rot = math.matrix([[math.cos(theta), -math.sin(theta)], [math.sin(theta), math.cos(theta)]]);
  const mat_sigma = math.matrix([[sigma1**2, 0], [0, sigma2**2]]);
  return math.multiply(mat_rot, math.multiply(mat_sigma, math.transpose(mat_rot)));
}


function mvnpdf(x, mu, Sigma){
  const p = math.matrix(mu).size()[0];
    return (2*math.pi)**(-p/2)*math.det(Sigma)**(-0.5)*
      math.exp(-0.5*math.multiply( math.multiply( math.transpose(math.subtract(x,mu)), math.inv(Sigma)), math.subtract(x,mu)))
}

{

var npoints=100, mini = -5, maxi=5, x = new Array(npoints), y = new Array(npoints), z = new Array(npoints), i, j;

//  create x y and z arrays for the contour plot, with x and y in the range -5, 5, for npoints points
for(var i = 0; i < npoints; i++) {
    x[i] = mini + i * (maxi - mini) / (npoints - 1);
    y[i] = mini + i * (maxi - mini) / (npoints - 1);
    z[i] = new Array(npoints);
    }

for(var i = 0; i < npoints; i++) {
  	for(j = 0; j < npoints; j++) {

    	z[i][j] = mvnpdf([x[i], x[j]], [mu1, mu2], create_sigma(theta, sigma1, sigma2));
 	}

}

function randn(n){
  return d3.range(n).map(d => jstat.normal.sample(0,1))
}

function mvnrand(mu, Sigma, n = 1){
  const p = math.matrix(mu).size()[0]
  if (n==1){
    return math.add(mu, math.multiply(jstat.cholesky(Sigma),randn(p))) 
  }else{
    return d3.range(n).map(d => math.add(mu, math.multiply(jstat.cholesky(Sigma), randn(2))) )
  }
}
// Create 100 samples from the multivariate normal distribution with the given parameters  using dists:
// const samples = mvnrand([mu1, mu2], create_sigma(theta, sigma1, sigma2), 100);
// var samples = dist["multivariate-normal"].samples([mu1, mu2], create_sigma(theta, sigma1, sigma2), 100);
// function randn(n){
//   return d3.range(n).map(d => dists["normal"].samples(1, 0, 1))
// }

// function mvnrand(mu, Sigma, n = 1){
//   const p = math.matrix(mu).size()[0]
//   if (n==1){
//     return math.add(mu, math.multiply(jstat.cholesky(Sigma),randn(p))) 
//   }else{
//     return d3.range(n).map(d => math.add(mu, math.multiply(jstat.cholesky(Sigma),randn(2))) )
//   }
// }


// Create 100 samples from the multivariate normal distribution with the given parameters


//extract n_samples from samples
// samples = samples.slice(0, n_samples);


{

var samples_mult = d3.range(100).map(d => math.add([mu1, mu2], math.multiply(jstat.cholesky([mu1, mu2], create_sigma(theta, sigma1, sigma2)), randn(2))));

var trace22 = {
        x: x,
        y: y,
        z: z,
        type: 'surface',
        colorscale: 'Oranges',
        showscale: false,
        color: {
            legend: false,
            label: "pdf",
        },

}


var trace21 = {
        x: x,
        y: y,
        z: z,
        type: 'contour',
        colorscale: 'Oranges',
        color: {
            legend: true,
            label: "pdf",
        },
        blur: 4,
        xaxis: 'x2',
}

// can you extract the samples from the multivariate normal distributionin samples_mult


// from samples_mult extract the x and y coordinates and plot them on the same plot as the contour plot


var trace1 = {
        x: samples_mult[0,0],
        y: samples_mult[0,1],
        mode: 'markers',
        type: 'scatter',
        marker: {
            color: 'rgba(0,0,0,0.5)',
            size: 25,
        },
        xaxis: 'x2',
}
// var trace1 = {
//         x: [1.5, 2.5, 3.5, 4.5, 5.5],
//         y: [4, 1, 7, 1, 4],
//         mode: 'markers',
//         type: 'scatter',
//         marker: {
//             color: 'rgba(0,0,0,0.5)',
//             size: 25,
//         },
//         xaxis: 'x2',
// }

// var trace1 = {
//         x: samples_mult.map(d => d[0]),
//         y: samples_mult.map(d => d[1]),
//         mode: 'markers',
//         type: 'scatter',
//         marker: {
//             color: 'rgba(0,0,0,0.5)',
//             size: 25,
//         },
//         xaxis: 'x2',
// }

// var trace1 = {
//         x: samples_mult.map(d => d[0]),
//         y: samples_mult.map(d => d[1]),
//         mode: 'markers',
//         type: 'scatter',
//         marker: {
//             color: 'rgba(0,0,0,0.5)',
//             size: 25,
//         },
//         xaxis: 'x2',
// }



var data = [
  trace21,
  trace22,
  trace1,
  ];


var layout = {
    scene: {
        camera: {
            eye: {
                x: 0.5,
                y: 1.2,
                z: 1.5,
            }
        }
    },
  grid: {
    rows: 1,
    columns: 2,
    subplots: [['xy','x2y']]
   },

    showlegend: false,

};

    var config = {responsive: true}
    const div = DOM.element('div');
    Plotly.newPlot(div, data, layout, config);
    return div;
  }

}

```