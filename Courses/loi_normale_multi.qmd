---
title: "Loi normale: cas multivarié"
format:
  html:
      out.width: 50%
filters:
  - shinylive
---

# Loi normale: cas multivarié

## Introduction

```{ojs}
//| echo: false
// Plotly = require("https://cdn.plot.ly/plotly-latest.min.js")
Plotly = require('plotly.js-dist');
dists = require( 'https://cdn.jsdelivr.net/gh/stdlib-js/stats-base-dists@umd/browser.js' );
math = require("mathjs");
// see source here: https://github.com/stdlib-js/stats-base-dists/tree/umd
// continuous case

viewof inputs = Inputs.form([
  Inputs.range([-1, 1], {label: tex`\mu_1`, step: 0.1}),
  Inputs.range([-1, 1], {label: tex`\mu_2`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_1`, step: 0.1}),
  Inputs.range([0.1, 2], {label: tex`\sigma_2`, step: 0.1}),
  Inputs.range([0, 6.29], {label: tex`\theta`, step: 0.01}),
  Inputs.range([1, 100], {label: tex`n`, step: 1}),
])

mu1 = inputs[0];
mu2 = inputs[1];

sigma1 = inputs[2];
sigma2 = inputs[3];

theta = inputs[4];

n_samples = inputs[5];


//  create a function that takes theta sigma1 and sigma2 and return the covariance matrix


function create_sigma(theta, sigma1, sigma2){
  const mat_rot = math.matrix([[math.cos(theta), -math.sin(theta)], [math.sin(theta), math.cos(theta)]]);
  const mat_sigma = math.matrix([[sigma1**2, 0], [0, sigma2**2]]);
  return math.multiply(mat_rot, math.multiply(mat_sigma, math.transpose(mat_rot)));
}


function mvnpdf(x, mu, Sigma){
  const p = math.matrix(mu).size()[0];
    return (2*math.pi)**(-p/2)*math.det(Sigma)**(-0.5)*
      math.exp(-0.5*math.multiply( math.multiply( math.transpose(math.subtract(x,mu)), math.inv(Sigma)), math.subtract(x,mu)))
}


function mvnormal_on_grid(){
  const ngridx1 = 50;
  const ngridx2 = 50;
  var griddata = [];
  for (let x1 of d3.range(-5, 5, 10/ngridx1)){
    for (let x2 of d3.range(-5, 5, 10/ngridx2)){
      griddata.push({x1: x1, x2: x2, pdf: mvnpdf([x1, x2], [mu1,mu2], create_sigma(theta, sigma1, sigma2))  })
    }
  }
  return griddata
}


{

//   const ngridx1 = 50;
//   const ngridx2 = 50;
//   var griddata = [];
//   for (let x1 of d3.range(-5, 5, 10/ngridx1)){
//     for (let x2 of d3.range(-5, 5, 10/ngridx2)){
//       griddata.push({x1: x1, x2: x2, pdf: mvnpdf([x1, x2], [mu1,mu2], create_sigma(theta, sigma1, sigma2))  })
//     }
//   }

    //  create matrix Sigma as a product of three matrix with sin theta and cos theta

    // const maxpdf = mvnpdf([mu1,mu2], [mu1,mu2], Sigma);
    // const x = d3.range(-5, 5, 0.01);


var npoints=100, mini = -5, maxi=5, x = new Array(npoints), y = new Array(npoints), z = new Array(npoints), i, j;

//  create x y and z arrays for the contour plot, with x and y in the range -5, 5, for npoints points
for(var i = 0; i < npoints; i++) {
    x[i] = mini + i * (maxi - mini) / (npoints - 1);
    y[i] = mini + i * (maxi - mini) / (npoints - 1);
    z[i] = new Array(npoints);
    }

for(var i = 0; i < npoints; i++) {
  	for(j = 0; j < npoints; j++) {

    	z[i][j] = mvnpdf([x[i], x[j]], [mu1,mu2], create_sigma(theta, sigma1, sigma2));
 	}

}



{

//  create a trace with a contour Plot of the function             Plot.contour(mvnormal_on_grid(), {filter: d => d.pdf > Number.EPSILON, x: "x1", y: "x2", fill: "pdf", stroke: "black", blur: 4})

var trace21 = {
        x: x,
        y: y,
        z: z,
        type: 'contour',
        color: {
            legend: true,
            type: "diverging",
            label: "pdf",
        },
        blur: 4,
        // marks: [
        //     Plot.contour(mvnormal_on_grid(), {filter: d => d.pdf > Number.EPSILON, x: "x1", y: "x2", fill: "pdf", stroke: "black", blur: 4})
        // ],
        // xaxis: 'x1',
        // yaxis: 'y1',
}




// var trace21 = {
//         x: {label: "x₁", domain: [-5,5]},
//         y: {label: "x₂", domain: [-5,5]},
//         color: {
//             legend: true,
//             type: "diverging",
//             label: "pdf",
//         },
//         marks: [
//             Plot.contour(mvnormal_on_grid(), {filter: d => d.pdf > Number.EPSILON, x: "x1", y: "x2", fill: "pdf", stroke: "black", blur: 4})
//         ],
//         xaxis: 'x1',
//         yaxis: 'y1',
// }

// var trace22 = {
//         x : [mu1, mu1],
//         y : [mu1, 1],
//         mode: 'lines',
//         line: {
//             dash: 'dash',
//             width: 1,
//             color: ' #428BCA',
//             marks: {
//                 size: 0,
//                 color: ' #428BCA',
//             }

//           },
//       xaxis: 'x1',
//       yaxis: 'y2'
// }


var data = [
  trace21
//   trace22,
  ];


var layout = {

  title: 'Distribution et quantile',
//   xaxis: {
//     domain: [0, 0.32],
//     anchor: 'y1'
//   },
//   xaxis2: {
//     domain: [0.35, 1],
//     anchor: 'y'
//   },

// legend offset
  showlegend: false,
  height: 680,

};
// XXX: TODO: put the xticks labels on the middle plot for x and on the right plot for y
    var config = {responsive: true}
    const div = DOM.element('div');
    Plotly.newPlot(div, data, layout, config);
    return div;
  }

}

```